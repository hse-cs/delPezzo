#from sage.all import *   # import sage library, otherwise other imports break #type: ignore

from sage.modules.free_module_element import vector
from sage.geometry.toric_lattice import ToricLatticeElement
from sage.geometry.cone import Cone, ConvexRationalPolyhedralCone, normalize_rays
from collections.abc import Iterable
from typing import Generator, Self

#from delPezzo.surface import Surface


class Cone_relint(ConvexRationalPolyhedralCone):
    '''
    the relative interior of a polyhedral cone
    
    TESTS:
        >>> Cone_relint([[1]])
        1-d cone in 1-d lattice N
    '''

    def __init__(self, *args) -> None:
        if len(args) == 1 and isinstance(args[0], ConvexRationalPolyhedralCone):
            temp_cone = args[0]
        else:
            temp_cone = Cone(*args)
        super().__init__(temp_cone.rays(), temp_cone.lattice())

    def contains_relint(self, other:Self|ConvexRationalPolyhedralCone|ToricLatticeElement)-> bool:
        '''
        checks if self contains other

        TESTS:
            >>> Cone_relint([[1,0],[0,1]]).contains_relint(Cone_relint([[1,0]]))
            False
            >>> Cone_relint([[1,0],[0,1]]).contains_relint(Cone([[1,1]]))
            True
            >>> Cone_relint([[1,0],[0,1]]).contains_relint(Cone_relint([[1,0],[0,1]]))
            True
            >>> Cone_relint([[1,0],[0,1]]).contains_relint(Cone_relint([[1,1],[-1,1]]))
            False
            >>> Cone_relint([[1,0],[0,1]]).contains_relint(Cone_relint([[0,0]]))
            False
        '''
        if not isinstance(other, ConvexRationalPolyhedralCone):
            return self.relative_interior_contains(other)
        closure_contains_other = all(self.contains(ray) for ray in other.rays())
        contains_inner_point = self.relative_interior_contains(sum(other.rays()))
        return closure_contains_other and contains_inner_point

    def relints_intersect(self, other: Self|ConvexRationalPolyhedralCone) -> bool:
        '''
        check if relint of self intersects relint of other
        
        TESTS:
            >>> Cone_relint([[1,0],[0,1]]).relints_intersect(Cone([[1,0]]))
            False
            >>> Cone_relint([[1,0],[0,1]]).relints_intersect(Cone_relint([[1,1]]))
            True
            >>> Cone_relint([[1,0],[0,1]]).relints_intersect(Cone_relint([[1,0],[0,1]]))
            True
            >>> Cone_relint([[1,0],[0,1]]).relints_intersect(Cone_relint([[1,1],[-1,1]]))
            True
            >>> Cone_relint([[1,0],[0,1]]).relints_intersect(Cone_relint([[0,0]]))
            False
        '''
        intersection = self.intersection(other)
        interior_ray = sum(intersection.rays())
        return self.relative_interior_contains(interior_ray) and other.relative_interior_contains(interior_ray)

    @classmethod
    def _from_face_and_ray(cls, face:Self|ConvexRationalPolyhedralCone, ray:ToricLatticeElement) -> Self:
        '''
        return a cone generated by face and ray
        
        TESTS:
            >>> C = Cone([[1,0]])
            >>> Cone_relint._from_face_and_ray(C,C.lattice()([0,1])).contains(C.lattice()([1,1]))
            True
        '''
        rays = list(face.rays())+[ray]
        rays = sorted(normalize_rays(rays, face.lattice()))
        return cls(rays)

    def _faces_list(self) -> list[Self]:
        '''
        return all faces of self as Cone_relint objects
        
        TESTS:
        >>> len(Cone_relint([[1,0],[0,1]])._faces_list())
        4
        '''
        return [self.__class__(face) for faces_of_dim in self.faces() for face in faces_of_dim]
    
    def _subdivision_faces(self, ray: ToricLatticeElement) -> list[Self]:
        '''
        return faces of self that do not contain ray

        TESTS:
            >>> C=Cone_relint([[1,0],[0,1]]); C._subdivision_faces(C.lattice()([1,0]))[1].rays()
            N(0, 1)
            in 2-d lattice N
        '''
        return [face for face in self._faces_list() if not face.contains(ray)]

    def _subdivision_ray(self) -> ToricLatticeElement:
        '''
        returns a canonically chosen vector in relint

        TESTS:
            >>> Cone_relint([[1,0],[0,1]])._subdivision_ray()
            N(1, 1)
            >>> Cone_relint([[1,0]])._subdivision_ray()
            N(1, 0)
        '''
        return sum(self.rays())

    def subdivide(self, ray: ToricLatticeElement|None=None) -> Generator[Self, None, None]:
        '''
        return cones of subdivision along the ray

        relints of subdivision cones are disjoint and comprise self

        TESTS:
            >>> C = Cone_relint([[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1]])
            >>> cones = list(C.subdivide()); rays = C.rays()
            >>> import itertools as it
            >>> rays_subsets = it.chain.from_iterable(it.combinations(rays, r) for r in range(len(rays) + 1))
            >>> rays_sums = [sum(rays) for rays in rays_subsets]
            >>> shift = vector([1,0,0]); test_rays = [r+shift for r in rays_sums]
            >>> all(sum(c.contains_relint(v)==1 for c in cones) for v in test_rays)
            True
            >>> faces = C._faces_list()
            >>> all(sum(f.contains_relint(v)==1 for f in faces) for v in rays_sums)
            True
        '''
        if ray==None:
            ray = self._subdivision_ray()
        for face in self._subdivision_faces(ray):
            yield self.__class__._from_face_and_ray(face, ray)
